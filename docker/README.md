Klutshnik Demo Environment
==========================

This all should be in Docker Compose, but I deemed this enough for a tech demo

## KMS

(All commands assume CWD to be docker/kms)

Build the container:

`docker build . -t klutshnik-kms`

Run the container with name `kms1`:

`docker run --env KMS_NAME=kms1 -v "$(dirname $(pwd))"/config:/kms/klutshnik/config_host --rm -t klutshnik-kms`

This bind mounts the `docker/config` directory to the container and generates KMS public and private keys there.

You should launch at least 5 KMS containers from this image, every KMS container must have a unique name (`[A-Za-z0-9]+` to avoid trouble).

## Client

(All commands assume CWD to be docker/client)

Build:

`docker build . -t klutshnik-client`

The client must be launched after KMS's are up.

The client image is supposed to be used interactively. The startup script will drop you to a shell after generating klutshnik.cfg based on the files inside the host `config/` directory (previously generated by KMS's - don't forget to clean up!):

`docker run -v "$(dirname $(pwd))"/config:/client/klutshnik/config_host --rm -it klutshnik-client`

Inside the container:

```
cd python
./client.py -c genkey -t 3
```

This should connect to the KMS containters.

## Hacking

Keep in mind that the `config` directory shared among containers from the host serves as a communication channel that is necessarry to exchange public keys. The circular dependency on public keys (KMS needs Client's pubkey, Client needs KMS's pubkey) is resolved by symlinking from the shared directory, so the key file will always have up-to-date content (while keeping container-specific and shared config separated). 

Private keys obviously leak through this shared directory - keep in mind that this is just a demo!
